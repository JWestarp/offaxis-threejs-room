<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WiiDesktopVR Reimagined - Off-Axis Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #c {
      display: block;
      width: 100%;
      height: 100%;
    }

    #webcam {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 160px;
      height: 120px;
      border: 2px solid #333;
      border-radius: 8px;
      transform: scaleX(-1);
      opacity: 0.8;
      z-index: 100;
    }

    #webcam.hidden {
      display: none;
    }

    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      font-size: 13px;
      max-width: 280px;
      z-index: 100;
      transition: transform 0.3s ease;
    }

    #controls.collapsed {
      transform: translateX(-100%);
    }

    #toggleControls {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      border: 1px solid #0a0;
      color: #0f0;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      z-index: 101;
      transition: left 0.3s ease;
    }

    #toggleControls:hover {
      background: rgba(0,20,0,0.9);
    }

    #controls.collapsed ~ #toggleControls {
      left: 10px;
    }

    #controls:not(.collapsed) ~ #toggleControls {
      left: 300px;
    }

    #controls h3 {
      margin-bottom: 10px;
      color: #0f0;
      font-size: 14px;
    }

    #controls label {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    #controls input[type="range"] {
      flex: 1;
      min-width: 80px;
    }

    #controls input[type="number"] {
      width: 60px;
      background: #222;
      border: 1px solid #444;
      color: #fff;
      padding: 2px 5px;
      border-radius: 3px;
    }

    #controls select {
      background: #222;
      border: 1px solid #444;
      color: #fff;
      padding: 4px;
      border-radius: 3px;
    }

    #controls button {
      background: #0a0;
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
      margin-top: 5px;
    }

    #controls button:hover {
      background: #0c0;
    }

    #status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 100;
      max-width: 220px;
    }

    #debug {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 11px;
      z-index: 100;
    }

    .hidden { display: none !important; }

    kbd {
      background: #333;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
    }

    .control-group {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #333;
    }

    .control-group:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="c"></canvas>
  </div>

  <video id="webcam" autoplay playsinline></video>

  <button id="toggleControls" title="Einstellungen ein/ausblenden">‚öôÔ∏è</button>

  <div id="controls">
    <h3>üéÆ WiiDesktopVR Reimagined</h3>
    
    <div class="control-group">
      <label>
        Smoothing:
        <select id="smoothingType">
          <option value="oneeuro">One Euro Filter</option>
          <option value="ema">EMA</option>
          <option value="double">Double Exp</option>
          <option value="none">Aus</option>
        </select>
      </label>
      <label>
        St√§rke:
        <input type="range" id="smoothingAlpha" min="0.1" max="1" step="0.05" value="0.3">
        <span id="smoothingAlphaVal">0.3</span>
      </label>
    </div>

    <div class="control-group">
      <label>
        Bildschirm-Breite (m):
        <input type="number" id="screenWidth" min="0.1" max="2" step="0.01" value="0.37" style="width: 80px;">
      </label>
      <label>
        Bildschirm-H√∂he (m):
        <input type="number" id="screenHeight" min="0.1" max="2" step="0.01" value="0.19" style="width: 80px;">
      </label>
      <button id="applyScreenSize" style="margin-top: 5px;">üìê Gr√∂√üe anwenden</button>
    </div>

    <div class="control-group">
      <label>
        Raumtiefe:
        <input type="range" id="roomDepth" min="0.1" max="1" step="0.05" value="0.15">
        <span id="roomDepthVal">0.15m</span>
      </label>
      <label>
        Gitterlinien:
        <input type="range" id="gridLines" min="5" max="20" step="1" value="5">
        <span id="gridLinesVal">5</span>
      </label>
      <label>
        Liniendicke:
        <input type="range" id="gridLineWidth" min="1" max="10" step="0.5" value="3">
        <span id="gridLineWidthVal">3</span>
      </label>
    </div>

    <div class="control-group">
      <label>
        X-Bewegung:
        <input type="range" id="headScaleX" min="0" max="2" step="0.1" value="0.5">
        <span id="headScaleXVal">0.5</span>
      </label>
      <label>
        Y-Bewegung:
        <input type="range" id="headScaleY" min="0" max="2" step="0.1" value="0.5">
        <span id="headScaleYVal">0.5</span>
      </label>
      <label>
        Tiefen√§nderung:
        <input type="range" id="depthFactor" min="0" max="1" step="0.1" value="0.3">
        <span id="depthFactorVal">0.3</span>
      </label>
    </div>

    <div class="control-group">
      <label>
        <input type="checkbox" id="showTargets" checked>
        Schwebende Targets
      </label>
      <label>
        <input type="checkbox" id="showChromeSphere">
        Chrome-Kugel
      </label>
      <label>
        <input type="checkbox" id="showFog" checked>
        Nebel-Effekt
      </label>
      <label>
        <input type="checkbox" id="showVideo" checked>
        Webcam anzeigen
      </label>
    </div>

    <div class="control-group" id="chromeControls" style="display: none;">
      <label>
        Textur-Gr√∂√üe:
        <input type="range" id="chromeTextureScale" min="0.5" max="3" step="0.1" value="2.1">
        <span id="chromeTextureScaleVal">2.1</span>
      </label>
      <label>
        W√∂lbung/Verzerrung:
        <input type="range" id="chromeCurvature" min="0.5" max="2.5" step="0.1" value="1.1">
        <span id="chromeCurvatureVal">1.1</span>
      </label>
      <label>
        Textur X-Offset:
        <input type="range" id="chromeTextureOffsetX" min="-1" max="1" step="0.05" value="0.60">
        <span id="chromeTextureOffsetXVal">0.60</span>
      </label>
      <label>
        Textur Y-Offset:
        <input type="range" id="chromeTextureOffsetY" min="-1" max="1" step="0.05" value="-0.60">
        <span id="chromeTextureOffsetYVal">-0.60</span>
      </label>
      <label style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333; display: block;">
        Metalness:
        <input type="range" id="chromeMetalness" min="0" max="1" step="0.05" value="1.00">
        <span id="chromeMetalnessVal">1.00</span>
      </label>
      <label>
        Roughness:
        <input type="range" id="chromeRoughness" min="0" max="1" step="0.05" value="0.45">
        <span id="chromeRoughnessVal">0.45</span>
      </label>
      <label>
        Env Map Intensit√§t:
        <input type="range" id="chromeEnvMapIntensity" min="0" max="1" step="0.05" value="0.20">
        <span id="chromeEnvMapIntensityVal">0.20</span>
      </label>
      <label style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333; display: block;">
        Ambient Light:
        <input type="range" id="ambientLightIntensity" min="0" max="2" step="0.1" value="0.5">
        <span id="ambientLightIntensityVal">0.5</span>
      </label>
      <label>
        Key Light:
        <input type="range" id="keyLightIntensity" min="0" max="3" step="0.1" value="0.3">
        <span id="keyLightIntensityVal">0.3</span>
      </label>
      <label>
        Fill Light:
        <input type="range" id="fillLightIntensity" min="0" max="2" step="0.1" value="0.6">
        <span id="fillLightIntensityVal">0.6</span>
      </label>
      <label>
        Back Light:
        <input type="range" id="backLightIntensity" min="0" max="2" step="0.1" value="0.4">
        <span id="backLightIntensityVal">0.4</span>
      </label>
      <label>
        Rim Light:
        <input type="range" id="rimLightIntensity" min="0" max="2" step="0.1" value="0.5">
        <span id="rimLightIntensityVal">0.5</span>
      </label>
    </div>

    <div class="control-group">
      <button id="randomizeTargets">üéØ Targets neu</button>
      <button id="resetView">üìç Zentrierung</button>
    </div>

    <div style="font-size: 11px; color: #888; margin-top: 8px;">
      <kbd>Space</kbd> Zentrierung &nbsp;
      <kbd>R</kbd> Targets &nbsp;
      <kbd>H</kbd> Hilfe
    </div>
    
    <div style="margin-top: 12px; padding: 8px; background: rgba(0,255,0,0.1); border: 1px solid #0a0; border-radius: 4px; font-size: 11px;">
      <strong style="color: #0f0;">üí° Kalibrierung:</strong><br>
      Positioniere dich mittig vor dem Bildschirm und dr√ºcke <kbd>Space</kbd> oder klicke "Zentrierung".
    </div>
  </div>

  <div id="status">
    Initialisiere...
  </div>

  <div id="debug">
    Head: X=0.00 Y=0.00 Z=0.50m
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.182.0/build/three.module.js';
    import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8';
    import { OffAxisCamera } from './src/core/OffAxisCamera.js';
    import { Screen } from './src/core/Screen.js';
    import { GridRoom, FloatingTargets, RoomFog } from './src/visualization/GridRoom.js';
    import { createSmoother } from './src/utils/smoothing.js';

    // ============ DOM Elements ============
    const canvas = document.getElementById('c');
    const video = document.getElementById('webcam');
    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');

    // ============ State ============
    let faceLandmarker = null;
    let webcamRunning = false;
    let lastVideoTime = -1;

    // Smoother
    let smoother = createSmoother('oneeuro', {
      minCutoff: 1.0,
      beta: 0.5,
      initial: { x: 0, y: 0, z: 0.8 }  // Weiter weg starten
    });

    // Head tracking offset (f√ºr Zentrierung)
    let headOffset = { x: 0, y: 0 };

    // ============ Three.js Setup ============
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.z = 0.5;

    // Screen - Bildschirmgr√∂√üe MacBook Pro 16.2"
    const aspect = window.innerWidth / window.innerHeight;
    const diagInches = 16.2;  // MacBook Pro 16"
    const screen = Screen.fromDiagonal(diagInches, aspect);

    // Off-Axis Camera Controller
    const offAxisCam = new OffAxisCamera(camera, screen, {
      near: 0.01,
      far: 50,
      clampNear: true,
      depthFactor: 0.3,    // Weniger Tiefen√§nderung bei Z-Bewegung
      baseDistance: 0.55   // Typische Sitzdistanz ~55cm
    });

    // ============ Room Visualization ============
    console.log('Screen size:', screen.widthM, 'x', screen.heightM, 'm');
    
    // Raumtiefe: max(10cm, eingestellte Tiefe) f√ºr optische Mindesttiefe
    const initialRoomDepth = 0.15;
    let gridRoom = new GridRoom({
      width: screen.widthM,
      height: screen.heightM,
      depth: Math.max(0.1, initialRoomDepth),
      gridLines: 5,
      gridColor: 0xaaaaaa,  // Heller f√ºr bessere Sichtbarkeit
      frontDepth: 0,  // Kein Raum vor dem Bildschirm
      lineWidth: 3  // 3x dicker als Standard
    });
    scene.add(gridRoom.getObject3D());

    let floatingTargets = new FloatingTargets({
      count: 10,
      inFront: 3,
      scale: 0.015,  // Viel kleiner wie im Original (targetScale = 0.065 bei boxdepth=8)
      roomWidth: screen.widthM,
      roomHeight: screen.heightM,
      roomDepth: 1,
      color: 0x00ff00,
      showLines: true,
      lineColor: 0x00ff00  // Heller
    });
    scene.add(floatingTargets.getObject3D());

    const roomFog = new RoomFog(scene, {
      color: 0x000000,
      nearOffset: 0,
      range: 5
    });
    // Fog initial deaktiviert - zu aggressiv
    roomFog.setEnabled(false);

    // Screen-Rahmen zur Orientierung
    const screenFrame = screen.createFrameMesh(0x00ff00);
    scene.add(screenFrame);

    // ============ Chrome Sphere Setup ============
    // Webcam-Textur f√ºr Reflexion
    const webcamTexture = new THREE.VideoTexture(video);
    webcamTexture.minFilter = THREE.LinearFilter;
    webcamTexture.magFilter = THREE.LinearFilter;
    webcamTexture.format = THREE.RGBFormat;

    // Innere Kugel: Webcam-Textur als Basis mit Custom Shader f√ºr Fisheye-Kontrolle
    const webcamSphereMaterial = new THREE.ShaderMaterial({
      uniforms: {
        map: { value: webcamTexture },
        curvature: { value: 1.1 },
        textureScale: { value: 2.1 },
        offsetX: { value: 1.10 },  // 0.5 + 0.60 = zentriert + offset
        offsetY: { value: -0.60 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D map;
        uniform float curvature;
        uniform float textureScale;
        uniform float offsetX;
        uniform float offsetY;
        varying vec2 vUv;
        
        void main() {
          // Fisheye-Verzerrung: Je h√∂her curvature, desto st√§rker die Verzerrung
          vec2 center = vec2(0.5, 0.5);
          vec2 delta = vUv - center;
          float dist = length(delta);
          
          // Anpassbare Verzerrung
          float distortion = pow(dist, curvature);
          vec2 distortedUV = center + normalize(delta) * distortion;
          
          // Textur-Skalierung und Offset anwenden
          vec2 finalUV = distortedUV * vec2(-textureScale, textureScale); // Negativ f√ºr X-Spiegelung
          finalUV.x += offsetX;
          finalUV.y += offsetY;
          
          // Nur innerhalb des Kreises samplen
          if (length(vUv - center) > 0.5) {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
          } else {
            gl_FragColor = texture2D(map, finalUV);
          }
        }
      `
    });
    
    const webcamSphere = new THREE.Mesh(
      new THREE.SphereGeometry(0.079, 64, 64),
      webcamSphereMaterial
    );

    // √Ñu√üere Kugel: Chrome-Glanz-Layer (transparent)
    const chromeMaterial = new THREE.MeshPhysicalMaterial({
      metalness: 1.0,  // Wert aus Screenshot
      roughness: 0.45,  // Wert aus Screenshot
      transparent: true,
      opacity: 0.3,  // Weniger opak f√ºr bessere Sicht auf Webcam
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
      envMapIntensity: 0.20  // Wert aus Screenshot
    });

    const chromeGlassLayer = new THREE.Mesh(
      new THREE.SphereGeometry(0.08, 64, 64),
      chromeMaterial
    );

    // Gruppe aus beiden Kugeln - fix in Bildschirmmitte, direkt dahinter
    const chromeSphere = new THREE.Group();
    chromeSphere.add(webcamSphere);
    chromeSphere.add(chromeGlassLayer);
    chromeSphere.position.set(0, 0, 0);  // Direkt hinter Bildschirm (Z=0)
    chromeSphere.visible = false;
    scene.add(chromeSphere);

    // Starke Beleuchtung f√ºr Chrome-Glanz-Effekt
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.3);
    keyLight.position.set(2, 2, 2);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
    fillLight.position.set(-2, 1, 1);
    scene.add(fillLight);

    const backLight = new THREE.DirectionalLight(0xffffff, 0.4);
    backLight.position.set(0, 1, -2);
    scene.add(backLight);

    const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
    rimLight.position.set(0, -2, 0);
    scene.add(rimLight);

    // ============ MediaPipe Setup ============
    const MP_MODEL_URL = 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task';
    const MP_WASM_URL = 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm';

    async function setupFaceLandmarker() {
      statusEl.textContent = 'Lade MediaPipe...';
      const filesetResolver = await FilesetResolver.forVisionTasks(MP_WASM_URL);
      
      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: { 
          modelAssetPath: MP_MODEL_URL,
          delegate: 'CPU'
        },
        runningMode: 'VIDEO',
        numFaces: 1,
        minFaceDetectionConfidence: 0.4,
        minFacePresenceConfidence: 0.4,
        minTrackingConfidence: 0.5,
        outputFaceBlendshapes: false,
        outputFacialTransformationMatrixes: false
      });
      
      statusEl.textContent = 'MediaPipe bereit. Starte Webcam...';
    }

    async function setupWebcam() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }, 
          audio: false 
        });
        video.srcObject = stream;
        await video.play();
      } catch (err) {
        console.error('Webcam error:', err);
        statusEl.textContent = '‚ùå Fehler: ' + err.message;
        throw err;
      }
      
      await new Promise(resolve => {
        const check = () => {
          if (video.videoWidth > 0 && video.videoHeight > 0) resolve();
          else requestAnimationFrame(check);
        };
        check();
      });

      webcamRunning = true;
      console.log('Webcam ready:', video.videoWidth, 'x', video.videoHeight);
      
      // Warte 500ms damit Video stabil l√§uft
      await new Promise(resolve => setTimeout(resolve, 500));
      
      statusEl.textContent = '‚úÖ Tracking aktiv';
    }

    // ============ Face -> Head Position ============
    let frameCount = 0;
    let lastFaceDetected = false;
    const REAL_EYE_DISTANCE_M = 0.063; // 63mm durchschnittlicher Augenabstand

    function processLandmarks(landmarks) {
      if (!landmarks || landmarks.length === 0) {
        if (frameCount % 30 === 0) console.warn('No landmarks array');
        return null;
      }

      const face = landmarks[0];
      
      // Debug: Check face structure
      if (!face || face.length < 468) {
        if (frameCount % 30 === 0) console.warn('Invalid face landmarks array, length:', face?.length, 'expected: 478');
        return null;
      }
      
      // Augenlandmarks (MediaPipe Face Mesh Indizes)
      // 33 = rechtes Auge au√üen (vom Betrachter aus links)
      // 263 = linkes Auge au√üen (vom Betrachter aus rechts)
      const leftEye = face[33];
      const rightEye = face[263];
      
      // Pr√ºfe ob Landmarks existieren und g√ºltige Koordinaten haben
      if (!leftEye || !rightEye || !Number.isFinite(leftEye.x) || !Number.isFinite(leftEye.y) || !Number.isFinite(rightEye.x) || !Number.isFinite(rightEye.y)) {
        if (frameCount % 60 === 0) console.warn('Eye landmarks missing or invalid');
        return null;
      }

      // Augenabstand in normalisierten Koordinaten (0-1)
      const dx = rightEye.x - leftEye.x;
      const dy = rightEye.y - leftEye.y;
      const eyeDistNorm = Math.sqrt(dx * dx + dy * dy);

      // Pr√ºfe auf ung√ºltige Werte
      if (!Number.isFinite(eyeDistNorm) || eyeDistNorm <= 0.01) {
        if (frameCount % 60 === 0) console.warn('Invalid eye distance:', eyeDistNorm);
        return null;
      }

      // Augenabstand in Pixeln (bezogen auf Videobreite)
      const eyeDistPx = eyeDistNorm * video.videoWidth;

      // Z-Distanz-Berechnung (√§hnlich WiiDesktopVR)
      // Bei ~63mm echtem Augenabstand und typischer Webcam-Brennweite
      const focalLengthPx = video.videoWidth * 1.2; // Typische Webcam FOV ~60¬∞
      const zMeters = (REAL_EYE_DISTANCE_M * focalLengthPx) / eyeDistPx;

      // Clamp Z zu vern√ºnftigen Werten (0.2m - 2m)
      const zClamped = Math.max(0.2, Math.min(2.0, zMeters));

      // Mittelpunkt der Augen = Kopfposition
      const centerX = (leftEye.x + rightEye.x) / 2;
      const centerY = (leftEye.y + rightEye.y) / 2;

      // Normalisiert zu -0.5 bis +0.5
      const normX = centerX - 0.5;
      const normY = -(centerY - 0.5); // Y invertiert (Webcam-Koordinaten nach oben = positiv)

      // Webcam FOV (typisch ~60¬∞ horizontal f√ºr Standard-Webcams)
      const fovHorizontal = 60 * Math.PI / 180;
      const aspectRatio = video.videoWidth / video.videoHeight;
      const fovVertical = fovHorizontal / aspectRatio;

      // Winkel berechnen (wie WiiDesktopVR: radiansPerPixel * position)
      const angleX = normX * fovHorizontal;
      const angleY = normY * fovVertical;

      // X und Y mit Z skalieren (wie WiiDesktopVR: x = sin(angle) * distance)
      // X invertiert f√ºr korrekte Links/Rechts-Bewegung
      const x = -Math.sin(angleX) * zClamped;
      const y = Math.sin(angleY) * zClamped;

      return { x, y, z: zClamped };
    }

    // ============ Animation Loop ============
    let currentHead = { x: 0, y: 0, z: 0.8 };  // Start weiter weg vom Bildschirm

    function animate() {
      requestAnimationFrame(animate);

      // Face Tracking - Frame-Skipping f√ºr Stabilit√§t (nur jeden 2. Frame)
      if (faceLandmarker && webcamRunning && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        frameCount++;
        
        // Skip jeden 2. Frame f√ºr bessere Performance
        if (frameCount % 2 !== 0) {
          return;
        }
        
        // Pr√ºfe ob Video wirklich bereit ist
        if (video.readyState < 2 || video.videoWidth === 0 || video.videoHeight === 0) {
          if (frameCount % 60 === 0) console.warn('Video not ready:', video.readyState);
          return;
        }
        
        // Pr√ºfe ob Video wirklich bereit ist
        if (video.readyState < 2 || video.videoWidth === 0 || video.videoHeight === 0) {
          if (frameCount % 60 === 0) console.warn('Video not ready, readyState:', video.readyState);
          return;
        }
        
        try {
          // Verwende video.currentTime statt performance.now() f√ºr besseres Timing
          const timestamp = video.currentTime * 1000;
          const results = faceLandmarker.detectForVideo(video, timestamp);
          
          if (!results) {
            console.warn('No results from faceLandmarker');
            statusEl.textContent = '‚ö†Ô∏è Tracking-Fehler: Keine Ergebnisse';
            return;
          }
          
          const hasFace = results.faceLandmarks && results.faceLandmarks.length > 0;
          
          // Log nur bei Status√§nderung oder alle 60 Frames
          if (hasFace !== lastFaceDetected) {
            console.log(`Frame ${frameCount}: Face detected changed to ${hasFace}`);
            if (!hasFace && results.faceLandmarks) {
              console.log('  Landmarks present but empty:', results.faceLandmarks.length);
            }
            lastFaceDetected = hasFace;
          } else if (frameCount % 60 === 0) {
            console.log(`Frame ${frameCount}: Face detected = ${hasFace}`);
          }
          
          if (hasFace) {
            const rawHead = processLandmarks(results.faceLandmarks);
            if (rawHead) {
              // Comprehensive Sanity Checks (typische Werte: X/Y: -0.3 bis +0.3m, Z: 0.3-1.5m)
              const isValid = Number.isFinite(rawHead.x) && 
                             Number.isFinite(rawHead.y) && 
                             Number.isFinite(rawHead.z) &&
                             Math.abs(rawHead.x) < 1.0 &&  // Max ¬±1m horizontal
                             Math.abs(rawHead.y) < 1.0 &&  // Max ¬±1m vertikal
                             rawHead.z > 0.1 &&             // Min 10cm vom Bildschirm
                             rawHead.z < 3.0;               // Max 3m vom Bildschirm
              
              if (!isValid) {
                if (frameCount % 30 === 0) {
                  console.warn('Head position out of bounds:', rawHead);
                }
                // Behalte letzten g√ºltigen Wert bei - KEIN Update
              } else {
                // Log alle 30 frames
                if (frameCount % 30 === 0) {
                  console.log('Valid head:', rawHead);
                }
                
                // Offset anwenden
                rawHead.x -= headOffset.x;
                rawHead.y -= headOffset.y;

                // Smoothing nur mit g√ºltigen Werten
                currentHead = smoother.update(rawHead);
                
                statusEl.textContent = '‚úÖ Gesicht erkannt';
              }
            }
          } else {
            statusEl.textContent = '‚ö†Ô∏è Kein Gesicht erkannt';
          }
        } catch (err) {
          console.error('Face detection error:', err);
          statusEl.textContent = '‚ùå Tracking-Fehler: ' + (err.message || 'Unbekannt');
          
          // Bei kritischen Fehlern: MediaPipe neustarten
          if (err.message && err.message.includes('abort')) {
            console.error('Critical error - MediaPipe might be crashed');
            webcamRunning = false;
            faceLandmarker = null;
          }
        }
      }

      // Off-Axis Projektion aktualisieren
      // Skaliere X/Y Bewegung mit den Parametern
      const scaledX = currentHead.x * headScaleX;
      const scaledY = currentHead.y * headScaleY;
      const eyePos = new THREE.Vector3(scaledX, scaledY, currentHead.z);
      const result = offAxisCam.update(eyePos);
      
      // Debug: Zeige wenn Projektion fehlschl√§gt
      if (!result.ok) {
        console.warn('Off-axis update failed:', result.reason);
      }

      // Fog aktualisieren
      roomFog.update(currentHead.z);

      // Debug-Ausgabe
      debugEl.textContent = `Head: X=${currentHead.x.toFixed(3)} Y=${currentHead.y.toFixed(3)} Z=${currentHead.z.toFixed(3)}m`;

      renderer.render(scene, camera);
    }

    // ============ UI Controls ============
    const smoothingTypeEl = document.getElementById('smoothingType');
    const smoothingAlphaEl = document.getElementById('smoothingAlpha');
    const roomDepthEl = document.getElementById('roomDepth');
    const gridLinesEl = document.getElementById('gridLines');
    const showTargetsEl = document.getElementById('showTargets');
    const showFogEl = document.getElementById('showFog');
    const headScaleXEl = document.getElementById('headScaleX');
    const headScaleYEl = document.getElementById('headScaleY');
    const depthFactorEl = document.getElementById('depthFactor');
    const screenWidthEl = document.getElementById('screenWidth');
    const screenHeightEl = document.getElementById('screenHeight');
    const applyScreenSizeEl = document.getElementById('applyScreenSize');

    // Setze initiale Werte basierend auf berechnetem Screen
    screenWidthEl.value = screen.widthM.toFixed(2);
    screenHeightEl.value = screen.heightM.toFixed(2);

    // Skalierungsfaktoren f√ºr Kopfbewegung
    let headScaleX = 0.5;
    let headScaleY = 0.5;
    const showVideoEl = document.getElementById('showVideo');
    const showChromeSphereEl = document.getElementById('showChromeSphere');
    const toggleControlsEl = document.getElementById('toggleControls');
    const controlsEl = document.getElementById('controls');

    // Toggle controls button
    toggleControlsEl.addEventListener('click', () => {
      controlsEl.classList.toggle('collapsed');
    });

    // Bildschirmgr√∂√üe anwenden
    applyScreenSizeEl.addEventListener('click', () => {
      const newWidth = parseFloat(screenWidthEl.value);
      const newHeight = parseFloat(screenHeightEl.value);
      
      if (!newWidth || !newHeight || newWidth <= 0 || newHeight <= 0) {
        statusEl.textContent = '‚ùå Ung√ºltige Bildschirmgr√∂√üe';
        return;
      }
      
      // Aktualisiere Screen
      screen.widthM = newWidth;
      screen.heightM = newHeight;
      screen.updateCorners();
      
      // Entferne alten Room
      scene.remove(gridRoom.getObject3D());
      gridRoom.dispose();
      
      // Erstelle neuen Room mit neuer Gr√∂√üe
      gridRoom = new GridRoom({
        width: newWidth,
        height: newHeight,
        depth: Math.max(0.1, parseFloat(roomDepthEl.value)),
        gridLines: parseInt(gridLinesEl.value),
        gridColor: 0xaaaaaa,
        lineWidth: parseFloat(document.getElementById('gridLineWidth').value)
      });
      scene.add(gridRoom.getObject3D());
      
      // Entferne alte Targets
      scene.remove(floatingTargets.getObject3D());
      floatingTargets.dispose();
      
      // Erstelle neue Targets mit neuer Raumgr√∂√üe
      floatingTargets = new FloatingTargets({
        count: 10,
        inFront: 3,
        scale: 0.015,
        roomWidth: newWidth,
        roomHeight: newHeight,
        roomDepth: Math.max(0.1, parseFloat(roomDepthEl.value)),
        color: 0x00ff00,
        showLines: true,
        lineColor: 0x00ff00
      });
      scene.add(floatingTargets.getObject3D());
      
      // Entferne alten Screen-Rahmen
      scene.remove(screenFrame);
      
      // Erstelle neuen Screen-Rahmen
      screenFrame = screen.createFrameMesh(0x00ff00);
      scene.add(screenFrame);
      
      // Aktualisiere OffAxisCamera mit neuem Screen
      offAxisCam.screen = screen;
      
      statusEl.textContent = `‚úÖ Bildschirm: ${newWidth.toFixed(2)}m x ${newHeight.toFixed(2)}m`;
      console.log('Screen updated:', screen);
    });

    smoothingTypeEl.addEventListener('change', () => {
      const type = smoothingTypeEl.value;
      const alpha = parseFloat(smoothingAlphaEl.value);
      smoother = createSmoother(type, { 
        alpha, 
        minCutoff: alpha * 3,
        beta: 0.5,
        initial: currentHead 
      });
    });

    smoothingAlphaEl.addEventListener('input', () => {
      const val = parseFloat(smoothingAlphaEl.value);
      document.getElementById('smoothingAlphaVal').textContent = val.toFixed(2);
      if (smoother.setAlpha) smoother.setAlpha(val);
    });

    roomDepthEl.addEventListener('input', () => {
      const val = parseFloat(roomDepthEl.value);
      document.getElementById('roomDepthVal').textContent = val + 'm';
      
      // Room neu bauen mit minimaler Tiefe von 10cm
      scene.remove(gridRoom.getObject3D());
      gridRoom.dispose();
      gridRoom = new GridRoom({
        width: screen.widthM,
        height: screen.heightM,
        depth: Math.max(0.1, val),  // Minimum 10cm
        gridLines: parseInt(gridLinesEl.value),
        gridColor: 0xaaaaaa,
        lineWidth: parseFloat(document.getElementById('gridLineWidth').value)
      });
      scene.add(gridRoom.getObject3D());
    });

    gridLinesEl.addEventListener('input', () => {
      const val = parseInt(gridLinesEl.value);
      document.getElementById('gridLinesVal').textContent = val;
      
      scene.remove(gridRoom.getObject3D());
      gridRoom.dispose();
      gridRoom = new GridRoom({
        width: screen.widthM,
        height: screen.heightM,
        depth: Math.max(0.1, parseFloat(roomDepthEl.value)),  // Minimum 10cm
        gridLines: val,
        gridColor: 0xaaaaaa,
        lineWidth: parseFloat(document.getElementById('gridLineWidth').value)
      });
      scene.add(gridRoom.getObject3D());
    });

    // Grid Line Width Control
    document.getElementById('gridLineWidth').addEventListener('input', () => {
      const val = parseFloat(document.getElementById('gridLineWidth').value);
      document.getElementById('gridLineWidthVal').textContent = val;
      
      scene.remove(gridRoom.getObject3D());
      gridRoom.dispose();
      gridRoom = new GridRoom({
        width: screen.widthM,
        height: screen.heightM,
        depth: Math.max(0.1, parseFloat(roomDepthEl.value)),
        gridLines: parseInt(gridLinesEl.value),
        gridColor: 0xaaaaaa,
        lineWidth: val
      });
      scene.add(gridRoom.getObject3D());
    });

    // Head Scale X/Y Event Listener
    headScaleXEl.addEventListener('input', () => {
      headScaleX = parseFloat(headScaleXEl.value);
      document.getElementById('headScaleXVal').textContent = headScaleX.toFixed(1);
    });

    headScaleYEl.addEventListener('input', () => {
      headScaleY = parseFloat(headScaleYEl.value);
      document.getElementById('headScaleYVal').textContent = headScaleY.toFixed(1);
    });

    depthFactorEl.addEventListener('input', () => {
      const val = parseFloat(depthFactorEl.value);
      document.getElementById('depthFactorVal').textContent = val.toFixed(1);
      offAxisCam.setDepthFactor(val);
    });

    showTargetsEl.addEventListener('change', () => {
      floatingTargets.getObject3D().visible = showTargetsEl.checked;
    });

    // Initial state f√ºr Checkbox synchronisieren
    showFogEl.checked = false;
    
    showFogEl.addEventListener('change', () => {
      roomFog.setEnabled(showFogEl.checked);
    });

    showVideoEl.addEventListener('change', () => {
      video.classList.toggle('hidden', !showVideoEl.checked);
    });

    showChromeSphereEl.addEventListener('change', () => {
      chromeSphere.visible = showChromeSphereEl.checked;
      // Zeige/verstecke Chrome-Einstellungen
      document.getElementById('chromeControls').style.display = 
        showChromeSphereEl.checked ? 'block' : 'none';
      // Wenn Chrome-Kugel aktiviert, verstecke Targets
      if (showChromeSphereEl.checked) {
        showTargetsEl.checked = false;
        floatingTargets.getObject3D().visible = false;
      } else {
        showTargetsEl.checked = true;
        floatingTargets.getObject3D().visible = true;
      }
    });

    // ============ Chrome Sphere Texture Controls ============
    const chromeTextureScaleEl = document.getElementById('chromeTextureScale');
    const chromeCurvatureEl = document.getElementById('chromeCurvature');
    const chromeTextureOffsetXEl = document.getElementById('chromeTextureOffsetX');
    const chromeTextureOffsetYEl = document.getElementById('chromeTextureOffsetY');

    chromeTextureScaleEl.addEventListener('input', (e) => {
      const scale = parseFloat(e.target.value);
      document.getElementById('chromeTextureScaleVal').textContent = scale.toFixed(1);
      webcamSphereMaterial.uniforms.textureScale.value = scale;
    });

    chromeCurvatureEl.addEventListener('input', (e) => {
      const curvature = parseFloat(e.target.value);
      document.getElementById('chromeCurvatureVal').textContent = curvature.toFixed(1);
      webcamSphereMaterial.uniforms.curvature.value = curvature;
    });

    chromeTextureOffsetXEl.addEventListener('input', (e) => {
      const offset = parseFloat(e.target.value);
      document.getElementById('chromeTextureOffsetXVal').textContent = offset.toFixed(2);
      webcamSphereMaterial.uniforms.offsetX.value = 0.5 + offset;
    });

    chromeTextureOffsetYEl.addEventListener('input', (e) => {
      const offset = parseFloat(e.target.value);
      document.getElementById('chromeTextureOffsetYVal').textContent = offset.toFixed(2);
      webcamSphereMaterial.uniforms.offsetY.value = offset;
    });

    // Chrome Material Properties Controls
    document.getElementById('chromeMetalness').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('chromeMetalnessVal').textContent = value.toFixed(2);
      chromeMaterial.metalness = value;
    });

    document.getElementById('chromeRoughness').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('chromeRoughnessVal').textContent = value.toFixed(2);
      chromeMaterial.roughness = value;
    });

    document.getElementById('chromeEnvMapIntensity').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('chromeEnvMapIntensityVal').textContent = value.toFixed(2);
      chromeMaterial.envMapIntensity = value;
    });

    // Light Intensity Controls
    document.getElementById('ambientLightIntensity').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('ambientLightIntensityVal').textContent = value.toFixed(1);
      ambientLight.intensity = value;
    });

    document.getElementById('keyLightIntensity').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('keyLightIntensityVal').textContent = value.toFixed(1);
      keyLight.intensity = value;
    });

    document.getElementById('fillLightIntensity').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('fillLightIntensityVal').textContent = value.toFixed(1);
      fillLight.intensity = value;
    });

    document.getElementById('backLightIntensity').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('backLightIntensityVal').textContent = value.toFixed(1);
      backLight.intensity = value;
    });

    document.getElementById('rimLightIntensity').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      document.getElementById('rimLightIntensityVal').textContent = value.toFixed(1);
      rimLight.intensity = value;
    });

    document.getElementById('randomizeTargets').addEventListener('click', () => {
      scene.remove(floatingTargets.getObject3D());
      floatingTargets.dispose();
      floatingTargets = new FloatingTargets({
        count: 10,
        inFront: 3,
        scale: 0.015,
        roomWidth: screen.widthM,
        roomHeight: screen.heightM,
        roomDepth: parseFloat(roomDepthEl.value),
        color: 0x00ff00,
        showLines: true,
        lineColor: 0x00ff00
      });
      scene.add(floatingTargets.getObject3D());
    });

    document.getElementById('resetView').addEventListener('click', () => {
      // Speichere aktuelle Position als Bildschirm-Zentrum (0,0)
      // Dies erlaubt absolute Positionsberechnung relativ zum Bildschirm
      headOffset = { x: currentHead.x, y: currentHead.y };
      console.log('Kalibriert auf Position:', currentHead);
      statusEl.textContent = '‚úÖ Kalibriert - Du bist jetzt im Zentrum';
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        // Kalibriere aktuelle Position als Bildschirm-Zentrum
        headOffset = { x: currentHead.x, y: currentHead.y };
        console.log('Kalibriert auf Position:', currentHead);
        statusEl.textContent = '‚úÖ Kalibriert - Du bist jetzt im Zentrum';
        e.preventDefault();
      }
      if (e.code === 'KeyR') {
        document.getElementById('randomizeTargets').click();
      }
      if (e.code === 'KeyH') {
        document.getElementById('controls').classList.toggle('hidden');
        debugEl.classList.toggle('hidden');
      }
    });

    // Resize
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // ============ Init ============
    async function init() {
      try {
        await setupFaceLandmarker();
        await setupWebcam();
        animate();
      } catch (err) {
        console.error(err);
        statusEl.textContent = '‚ùå Fehler: ' + err.message;
      }
    }

    init();
  </script>
</body>
</html>
